import numpy as np
import pandas as pd

snakemake.utils.min_version("9.0.0")

# Define wrapper versions
wrapper_ver = "v7.6.0"

######################
### Validate Input ###
######################
from urllib.parse import urlparse, urlunparse

baseurl = urlparse(workflow.current_basedir.get_path_or_uri())
# Units
units = config.get("units")
if units is None:
    # Testing
    units = (
        pd.read_table(
            "config/units.tsv",
            converters={"seq_type": (lambda x: x.casefold())},
            comment="#",
        )
        .set_index(["sample", "library", "lane"], drop=False)
        .assign(
            read_type_raw=lambda x: [["R1", "R2"]] * 5,
            read_type_trim=lambda x: [
                ["R1", "R2", "singleton", "collapsed", "collapsedtrunc"]
            ]
            * 5,
        )
    )

snakemake.utils.validate(
    units.drop(columns=["read_type_raw", "read_type_trim"]),
    schema=urlunparse(
        baseurl._replace(path=str(Path(baseurl.path) / "schemas" / "units.schema.yaml"))
    ),
)
# Config (default value for testing purposes)
config = config.get("cfg", config)
snakemake.utils.validate(
    config,
    schema=urlunparse(
        baseurl._replace(
            path=str(Path(baseurl.path) / "schemas" / "config.schema.yaml")
        )
    ),
)


##########################
### Read Dereplication ###
##########################
include: "rules/utils.smk"
include: "rules/extend.smk"
include: "rules/derep.smk"
include: "rules/repr_read.smk"
include: "rules/low_complex.smk"
include: "rules/nonpareil.smk"


rule multiqc:
    input:
        ### Merge lanes
        expand_pd(
            rules.fastqc.output.zip,
            units.assign(tool="merge_lanes", read_type_trim="collapsed"),
        ),
        expand_pd(
            rules.nonpareil_plot.output.json,
            units.assign(tool="merge_lanes", read_type_trim="collapsed"),
        ),
        ### Read extension
        expand_pd(
            rules.fastqc.output.zip,
            units.assign(tool="extend/tadpole", read_type_trim="collapsed"),
        )
        if is_activated("extension")
        else [],
        ### Read derep
        expand_pd(
            rules.fastqc.output.zip,
            units.assign(tool="derep", read_type_trim="collapsed"),
        )
        if is_activated("derep")
        else [],
        expand_pd(
            rules.nonpareil_plot.output.json,
            units.assign(tool="derep", read_type_trim="collapsed"),
        )
        if is_activated("derep")
        else [],
        ### Read grep
        expand_pd(
            rules.fastqc.output.zip,
            units.assign(tool="represent/grep", read_type_trim="collapsed"),
        )
        if is_activated("extension") and is_activated("derep")
        else [],
        ### Low complexity filter
        expand_pd(
            rules.fastqc.output.zip,
            units.assign(tool="low_complexity", read_type_trim="collapsed"),
        ),
    output:
        html="reports/multiqc.html",
        data="reports/multiqc_data.zip",
    log:
        "logs/reports/multiqc.log",
    benchmark:
        "benchmarks/reports/multiqc.log"
    params:
        extra="--force --clean-up " + config.get("report", {}).get("multiqc", ""),
    localrule: True
    threads: 1
    resources:
        mem=lambda w, attempt: f"{10* attempt} GiB",
        runtime=lambda w, attempt: f"{30* attempt} m",
    wrapper:
        f"{wrapper_ver}/bio/multiqc"


rule all:
    input:
        qc=rules.multiqc.output.html,
        res=expand_pd(
            expand(
                rules.low_complexity.output.out,
                read_type_trim="collapsed",
                allow_missing=True,
            ),
            units,
        ),
    message:
        "Read Dereplication/Extension finished successfully!"
    default_target: True
